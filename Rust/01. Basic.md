# Data Type
- Rust is a _statically typed_ language: every value in Rust is of a certain _data type_.
- There are two data type subsets: scalar and compound.

## Scalar Types

A _scalar_ type represents a single value. Rust has four primary scalar types: integers, floating-point numbers, Booleans, and characters

### Integer Types

| Length | Signed | Unsigned |
|---|---|---|
| 8-bit | i8 | u8 |
| 16-bit | i16 | u16 |
| 32-bit | i32 | u32 |
| 64-bit | i64 | u64 |
| 128-bit | i128 | u128 |
| arch | isize | usize |

- Signed numbers are stored using [two’s complement](https://en.wikipedia.org/wiki/Two%27s_complement) representation.
- `isize` and `usize` types depend on the architecture of the computer your program is running on

- Number literals allow a type suffix, such as `57u8`
| Number literals | Example |
|---|---|
| Decimal | 98_222 |
| Hex | 0xff |
| Octal | 0o77 |
| Binary | 0b1111_0000 |
| Byte (u8 only) | b'A' |

> Number literals can also use `_` as a visual separator to make the number easier to read, such as `1_000`

### Floating-Point 

- Rust’s floating-point types are `f32` and `f64`, which are 32 bits and 64 bits in size, respectively.
	- The `f32` type is a single-precision float
	- The `f64` has double precision.
- The default type is `f64`

### Boolean
- The Boolean type in Rust is specified using `bool`. 
- Boolean type has two possible values: `true` and `false`.
- Booleans are one byte in size.

### Character
- Rust’s `char` type is the language’s most primitive alphabetic type
- Rust’s `char` type is four bytes in size and represents a Unicode Scalar Value

> We specify `char` literals with single quotes, as opposed to string literals, which use double quotes

> A “character” isn’t really a concept in Unicode, so your human intuition for what a “character” is may not match up with what a `char` is in Rust


## Compound Types

_Compound types_ can group multiple values into one type. Rust has two primitive compound types: tuples and arrays.

### Tuple

- A tuple is a general way of grouping together a number of values with a variety of types
- Tuples have a fixed length: once declared, they **cannot** grow or shrink in size.

```rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
    let (x, y, z) = tup;
    println!("The value of y is: {}", y);
    println!("The value of x is: {}", tup.0);
}
```

- We can use pattern matching to destructure a tuple value.
- We can also access a tuple element directly by using a period (`.`) followed by the index of the value

> The tuple without any values, `()`, is is called the _unit type_ and the value is called the _unit value_. Expressions implicitly return the unit value if they don’t return any other value.


### Array

- Unlike a tuple, every element of an array must have the same type.
- Arrays in Rust have a **fixed** length.

- You write an array’s type using square brackets with the type of each element, a semicolon, and then the number of elements in the array.
```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```

- You can also initialize an array to contain the same value for many times.
```rust
let a = [3; 5]; // [3, 3, 3, 3, 3]
```

# Variables

## let

- By default variables are immutable. However, you can make them mutable by adding `mut` in front of the variable name.

```rust
let x = 5;
println!("The value of x is: {}", x);
x = 6; // Compile-time error

let mut y = 5;
y = 6;
```

- You can declare a new variable with the same name as a previous variable. We can shadow a variable by using the same variable’s name and repeating the use of the `let`.
	- The other difference between `mut` and shadowing is that we’re effectively creating a new variable when we use the `let` keyword again
	- The new variable don't need to be the same type as before.

```rust
fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {}", x);
    }

    println!("The value of x is: {}", x);
}

```

## const

- _Constants_ are values that are bound to a name and are not allowed to change, but there are a few differences between constants and variables.
	- You aren’t allowed to use `mut`.
	- Constants can be declared in any scope, including the global scope.
	- Constants may be set only to a constant expression, not the result of a value that could only be computed at runtime.

- You declare constants using the `const` keyword instead of the `let` keyword, and the type of the value _must_ be annotated.

```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```

# Functions

```rust
fn main() {
    println!("Hello, world!");

    another_function();
}

fn another_function() {
    println!("Another function.");
}

```

> Rust code uses _snake case_ as the conventional style for function and variable names

- The `main` function is the entry point of many programs.
- We define a function in Rust by entering `fn` followed by a function name and a set of parentheses.


## Parameters

```rust
fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("The measurement is: {}{}", value, unit_label);
}
```

- In function signatures, you _must_ declare the type of each parameter.
- When defining multiple parameters, separate the parameter declarations with commas.

## Statements and Expressions

> Rust is an **expression-based** language.

- _Statements_ are instructions that perform some action and do not return a value.
	- `let y = 6;` is a statement.
	- Function definitions are also statements
	- Statements do not return values: `let x = (let y = 6);` is an error.

- _Expressions_ evaluate to a resulting value.
	- `5 + 6` is an expression that evaluates to the value `11`.
	- Expressions can be part of statements
	- Calling a function is an expression.
	- Calling a macro is an expression
	- A new scope block created with curly brackets is an expression

```rust
fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {}", y);
}

```

> Expressions do not include ending semicolons. If you add a semicolon to the end of an expression, you turn it into a statement

## Return

```rust
fn five() -> i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {}", x);
}

```

- We don’t name return values, but we must declare their type after an arrow (`->`).
- In Rust, the return value of the function is synonymous with the value of the **final expression in the block** of the body of a function.
- You can return early from a function by using the `return` keyword


# Control Flow

## if

```rust
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}

```

- Condition _must_ be a `bool`. If the condition isn’t a `bool`, we’ll get an error.

```rust
fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {}", number);
}
```

- Because `if` is an **expression**, we can use it on the right side of a `let` statement to assign the outcome to a variable
- Expression results from each arm of the `if` must be the same type.

## match

```rust
fn main() {
    let number = 13;
    match number {
        1 => println!("One!"),
        // Match several values
        2 | 3 | 5 | 7 | 11 => println!("This is a prime"),
        // Match an inclusive range
        13..=19 => println!("A teen"),
        // Handle the rest of cases
        _ => println!("Ain't special"),
    }
}

```

## loop

```
fn main() {
    loop {
        println!("again!");
    }
}
```

- The `loop` keyword tells Rust to execute a block of code over and over again forever or until you explicitly tell it to stop.
	- You can place the `break` keyword within the loop to tell the program when to stop executing the loop
	- We can use `continue` to skip over any remaining code in this iteration and go to the next iteration.

```rust
fn main() {
    let mut count = 0;
    counting_up: loop {
        println!("count = {}", count);
        let mut remaining = 10;

        loop {
            println!("remaining = {}", remaining);
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {}", count);
}
```

- You can optionally specify a _loop label_ on a loop that we can then use with `break` or `continue` to specify that those keywords apply to the labeled loop instead of the innermost loop.

```rust
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {}", result);
}

```

- You can add the value you want returned after the `break` expression you use to stop the loop,

## while

```rust
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{}!", number);

        number -= 1;
    }

    println!("LIFTOFF!!!");
}
```

- It’s possible to implement behavior like this using a combination of `loop`, `if`, `else`, and `break`

## for

```rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {}", element);
    }

	for number in (1..4).rev() {
        println!("{}!", number);
    }

}

```