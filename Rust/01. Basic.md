# Data Type

- Rust is aÂ _statically typed_Â language: every value in Rust is of a certainÂ _data type_.
- There are two data type subsets: scalar and compound.

## Scalar Types

AÂ _scalar_Â type represents a single value. Rust has four primary scalar types: integers, floating-point numbers, Booleans, and characters

### Integer Types

| Length | Signed | Unsigned |
|---|---|---|
| 8-bit | i8 | u8 |
| 16-bit | i16 | u16 |
| 32-bit | i32 | u32 |
| 64-bit | i64 | u64 |
| 128-bit | i128 | u128 |
| arch | isize | usize |

- Signed numbers are stored usingÂ [twoâ€™s complement](https://en.wikipedia.org/wiki/Two%27s_complement)Â representation.
- `isize`Â andÂ `usize`Â types depend on the architecture of the computer your program is running on

- Number literals allow a type suffix, such asÂ `57u8`

| Number literals | Example |
|---|---|
| Decimal | 98_222 |
| Hex | 0xff |
| Octal | 0o77 |
| Binary | 0b1111_0000 |
| Byte (u8 only) | b'A' |

> Number literals can also useÂ `_`Â as a visual separator to make the number easier to read, such asÂ `1_000`


### Floating-Point 

- Rustâ€™s floating-point types areÂ `f32`Â andÂ `f64`, which are 32 bits and 64 bits in size, respectively.
	- TheÂ `f32`Â type is a single-precision float
	- The `f64`Â has double precision.
- The default type isÂ `f64`

```rust
fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;
    let truncated = -5 / 3; // Results in -1

    // remainder
    let remainder = 43 % 5;
}
```

### Boolean
- The Boolean type in Rust is specified usingÂ `bool`. 
- Boolean type has two possible values:Â `true`Â andÂ `false`.
- Booleans are one byte in size.

```rust
fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
```

### Character
- Rustâ€™sÂ `char`Â type is the languageâ€™s most primitive alphabetic type
- Rustâ€™sÂ `char`Â type is four bytes in size and represents a Unicode Scalar Value

```rust
fn main() {
    let c = 'z';
    let z: char = 'â„¤'; // with explicit type annotation
    let heart_eyed_cat = 'ğŸ˜»';
}
```

> We specifyÂ `char`Â literals with single quotes, as opposed to string literals, which use double quotes

> A â€œcharacterâ€ isnâ€™t really a concept in Unicode, so your human intuition for what a â€œcharacterâ€ is may not match up with what aÂ `char`Â is in Rust


## Compound Types

_Compound types_Â can group multiple values into one type. Rust has two primitive compound types: tuples and arrays.

### Tuple

- A tuple is a general way of grouping together a number of values with a variety of types
- Tuples have a fixed length: once declared, they **cannot** grow or shrink in size.

```rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
    let (x, y, z) = tup;
    println!("The value of y is: {}", y);
    println!("The value of x is: {}", tup.0);
}
```

- We can use pattern matching to destructure a tuple value.
- We can also access a tuple element directly by using a period (`.`) followed by the index of the value

> The tuple without any values,Â `()`, is is called theÂ _unit type_Â and the value is called theÂ _unit value_. Expressions implicitly return the unit value if they donâ€™t return any other value.


### Array

- Unlike a tuple, every element of an array must have the same type.
- Arrays in Rust have a **fixed** length.

- You write an arrayâ€™s type using square brackets with the type of each element, a semicolon, and then the number of elements in the array.
```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```

- You can also initialize an array to contain the same value for many times.
```rust
let a = [3; 5]; // [3, 3, 3, 3, 3]
```

# Variables

## let

- By default variables are immutable. However, you can make them mutable by addingÂ `mut`Â in front of the variable name.

```rust
let x = 5;
println!("The value of x is: {}", x);
x = 6; // Compile-time error

let mut y = 5;
y = 6;
```

- You can declare a new variable with the same name as a previous variable. We can shadow a variable by using the same variableâ€™s name and repeating the use of theÂ `let`.
	- The other difference betweenÂ `mut`Â and shadowing is that weâ€™re effectively creating a new variable when we use theÂ `let`Â keyword again
	- The new variable don't need to be the same type as before.

```rust
fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {}", x);
    }

    println!("The value of x is: {}", x);
}

```

## const

- _Constants_Â are values that are bound to a name and are not allowed to change, but there are a few differences between constants and variables.
	- You arenâ€™t allowed to useÂ `mut`.
	- Constants can be declared in any scope, including the global scope.
	- Constants may be set only to a constant expression, not the result of a value that could only be computed at runtime.

- You declare constants using theÂ `const`Â keyword instead of theÂ `let`Â keyword, and the type of the valueÂ _must_Â be annotated.

```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```

> Constants are valid for the entire time a program runs, within the scope in which they were declared. This property makes constants useful for values in your application domain that multiple parts of the program might need to know about, such as the maximum number of points any player of a game is allowed to earn, or the speed of light.
> 
# Functions

```rust
fn main() {
    println!("Hello, world!");

    another_function();
}

fn another_function() {
    println!("Another function.");
}

```

> Rust code usesÂ _snake case_Â as the conventional style for function and variable names

- TheÂ `main`Â function is the entry point of many programs.
- We define a function in Rust by enteringÂ `fn`Â followed by a function name and a set of parentheses.


## Parameters

```rust
fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("The measurement is: {}{}", value, unit_label);
}
```

- In function signatures, youÂ _must_Â declare the type of each parameter.
- When defining multiple parameters, separate the parameter declarations with commas.

## Statements and Expressions

> Rust is an **expression-based** language.

- _Statements_Â are instructions that perform some action and do not return a value.
	- `let y = 6;`Â is a statement.
	- Function definitions are also statements
	- Statements do not return values: `let x = (let y = 6);` is an error.

- _Expressions_Â evaluate to a resulting value.
	- `5 + 6` is an expression that evaluates to the valueÂ `11`.
	- Expressions can be part of statements
	- Calling a function is an expression.
	- Calling a macro is an expression
	- A new scope block created with curly brackets is an expression

```rust
fn main() {
    let y = {
        let x = 3; // This is a statement, declaring a new variable x within the block. // This is an expression, which becomes the value of the block.
        x + 1
    }; // The block is also an expression, evaluating to the value of the last expression within it.

    println!("The value of y is: {}", y);
}

```

> Expressions do not include ending semicolons. If you add a semicolon to the end of an expression, you turn it into a statement

## Return

```rust
fn five() -> i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {}", x);
}

```

- We donâ€™t name return values, but we must declare their type after an arrow (`->`).
- In Rust, the return value of the function is synonymous with the value of the **final expression in the block** of the body of a function.
- You can return early from a function by using theÂ `return`Â keyword

# Control Flow

## if

```rust
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}

```

- Condition _must_Â be aÂ `bool`. If the condition isnâ€™t aÂ `bool`, weâ€™ll get an error.

```rust
fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {}", number);
}
```

- BecauseÂ `if`Â is an **expression**, we can use it on the right side of aÂ `let`Â statement to assign the outcome to a variable
- Expression results from each arm of theÂ `if`Â must be the same type.

### if let

```rust
fn main() {
    let config_max = Some(3u8);
    if let Some(max) = config_max {
        println!("The maximum is configured to be {}", max);
    }
}

```

- The syntaxÂ `if let`Â takes a pattern and an expression separated by an equal sign. It works the same way as aÂ `match`
- You can think ofÂ `if let`Â as syntax sugar for aÂ `match`Â that runs code when the value matches one pattern and then ignores all other values.

## match

```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
	        println!("Lucky penny!");
	        1
	    }
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```

- When theÂ `match`Â expression executes, it compares the resulting value against the pattern of each arm, in order.
- If you want to run multiple lines of code in a match arm, you must use curly brackets.

```rust
#[derive(Debug)] // so we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        }
    }
}

fn main() {
    value_in_cents(Coin::Quarter(UsState::Alaska));
}

```

- Another useful feature of match arms is that they can bind to the parts of the values that match the pattern.

```rust
fn main() {
    let number = 13;
    match number {
        1 => println!("One!"),
        // Match several values
        2 | 3 | 5 | 7 | 11 => println!("This is a prime"),
        // Match an inclusive range
        13..=19 => println!("A teen"),
        // Handle the rest of cases
        _ => (),
    }
}

```

> Matches in Rust areÂ _exhaustive_: we must exhaust every last possibility in order for the code to be valid

- To match all possibility, we can use a variable to match any condition. The variable can be `_`, `other`, and anything.

## loop

```rust
fn main() {
    loop {
        println!("again!");
    }
}
```

- TheÂ `loop`Â keyword tells Rust to execute a block of code over and over again forever or until you explicitly tell it to stop.
	- You can place theÂ `break`Â keyword within the loop to tell the program when to stop executing the loop
	- We can useÂ `continue` to skip over any remaining code in this iteration and go to the next iteration.

```rust
fn main() {
    let mut count = 0;
    counting_up: loop {
        println!("count = {}", count);
        let mut remaining = 10;

        loop {
            println!("remaining = {}", remaining);
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {}", count);
}
```

- You can optionally specify aÂ _loop label_Â on a loop that we can then use withÂ `break`Â orÂ `continue`Â to specify that those keywords apply to the labeled loop instead of the innermost loop.

```rust
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {}", result);
}

```

- You can add the value you want returned after theÂ `break`Â expression you use to stop the loop,

## while

```rust
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{}!", number);

        number -= 1;
    }

    println!("LIFTOFF!!!");
}
```

- Itâ€™s possible to implement behavior like this using a combination ofÂ `loop`,Â `if`,Â `else`, andÂ `break`

## for

- Use `for` when you want to iterate over a collection or a specific range of values. The `for` loop is most suitable for situations where you know the exact number of iterations or when you want to loop over the elements of a collection, like an array, vector, or iterator.

```rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {}", element);
    }

	for number in (1..4).rev() {
        println!("{}!", number);
    }

}

```

# Collection

## Vec

```rust
fn main() {
    let v: Vec<i32> = Vec::new();
    let v = vec![1, 2, 3];
}
```

- `Vec<T>`, also known as aÂ _vector_, allows you to store more than one value in a single data structure
- To create a new empty vector, we call theÂ `Vec::new`Â function.
- Rust conveniently provides theÂ `vec!`Â macro, which will create a new vector that holds the values you give it.
- When the vector gets dropped, all of its contents are also dropped, meaning those integers it holds will be cleaned up.

```rust
fn main() {
    let mut v = Vec::new();

    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);
}
```

- If we want to be able to change its value, we need to make it mutable using theÂ `mut`Â keyword

```rust
fn main() {
    let v = vec![1, 2, 3, 4, 5];

    let third: &i32 = &v[2];
    println!("The third element is {}", third);

    match v.get(2) {
        Some(third) => println!("The third element is {}", third),
        None => println!("There is no third element."),
    }
}

```

- There are two ways to reference a value stored in a vector: 
	1. indexing
	2.Â `get`Â method: gives us anÂ `Option<&T>`

- `[]`Â method will cause the program to panic when it references a nonexistent element.
- When theÂ `get`Â method is passed an index that is outside the vector, it returnsÂ `None`Â without panicking.

> In Rust, if you try to access an element in a vector using the indexing syntax without using the reference operator `&`, you will encounter a compilation error. The reason for this is that the indexing syntax returns a reference to the element, so you need to use `&` to borrow the element instead of attempting to move it out of the vector.

```rust
fn main() {
    let v = vec![100, 32, 57];
    for i in &v {
        println!("{i}");
    }


    let mut v = vec![100, 32, 57];
    for i in &mut v {
        *i += 50;
    }
}
```

- We can also iterate over mutable references to each element in a mutable vector in order to make changes to all the elements

> Recall the rule that states you canâ€™t have mutable and immutable references in the same scope. If we attempted to insert or remove items in theÂ `for`Â loop bodies, we would get a compiler error

## Multiple Types

Vectors can only store values that are the same type. This can be inconvenient; there are definitely use cases for needing to store a list of items of different types.

```rust
fn main() {
    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Text(String::from("blue")),
        SpreadsheetCell::Float(10.12),
    ];
}

```

- We can define an enum whose variants will hold the different value types, and all the enum variants will be considered the same type.
- If you donâ€™t know the exhaustive set of types a program will get at runtime to store in a vector, the enum technique wonâ€™t work. Instead, you can use a trait object.

## String

- Rust has only one string type in the core language, which is the string sliceÂ `str`Â that is usually seen in its borrowed formÂ `&str`
	- String literals are statically allocated, immutable, and of a fixed size.
	- They are written as a sequence of characters enclosed in double quotes and have the type `&str`.
	- String literals are stored in the programâ€™s binary and are therefore string slices.

```rust
let greeting: &str = "Hello, world!";
```

- The `String` type is a growable, mutable, and heap-allocated string.
	- It represents a sequence of Unicode characters that can be changed during the runtime of the program.
-
- Rustâ€™s standard library also includes a number of other string types, such asÂ `OsString`,Â `OsStr`,Â `CString`
	- `Str` and `String` refer to owned and borrowed variants

```rust
fn main() {
    let s = String::new();

	let data = "initial contents";
    let s = data.to_string(); // to_string create String 

    // the method also works on a literal directly:
    let s = "initial contents".to_string();

    let s = String::from("initial contents");
}
```

- We can create `String` using `String::new()` as `Vec<T>`.
- We can also use `.to_string()` method on string literal to create `String`.
- We can also use the functionÂ `String::from`Â to create aÂ `String`Â from a string literal.
	- `String::from`Â andÂ `to_string`Â do the same thing, so which you choose is a matter of style and readability.

```rust
let hello = String::from("Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ…");
let hello = String::from("DobrÃ½ den");
let hello = String::from("Hello");
let hello = String::from("×©Ö¸××œ×•Ö¹×");
let hello = String::from("à¤¨à¤®à¤¸à¥à¤¤à¥‡");
let hello = String::from("ã“ã‚“ã«ã¡ã¯");
let hello = String::from("ì•ˆë…•í•˜ì„¸ìš”");
let hello = String::from("ä½ å¥½");
let hello = String::from("OlÃ¡");
let hello = String::from("Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ");
let hello = String::from("Hola");
```

- Remember that strings are UTF-8 encoded, so we can include any properly encoded data in them
- BothÂ `String`Â and string slices are UTF-8 encoded.

```rust
fn main() {
    let mut s = String::from("foo");
    s.push_str("bar");
    s.push('l');
}
```

- We can grow aÂ `String`Â by using theÂ `push_str`Â method to append a string slice.
- TheÂ `push`Â method takes a single character as a parameter and adds it to theÂ `String`.

```rust
fn main() {
    let s1 = String::from("Hello, ");
    let s2 = String::from("world!");
    let s3 = s1 + &s2; // note s1 has been moved here and can no longer be used
}
```

```rust
fn add(self, s: &str) -> String {
```

- You can combine two existing strings using theÂ `+`Â operator.
- TheÂ `+`Â operator uses theÂ `add`Â method, whose signature looks something like `fn add(self, s: &str) -> String`
	- `s2`Â has anÂ `&`, meaning that weâ€™re adding aÂ _reference_Â of the second string to the first string
	- TheÂ compiler canÂ _coerce_Â theÂ `&String`Â argument into aÂ `&str`. When we call theÂ `add`Â method, Rust uses aÂ _deref coercion_, which here turnsÂ `&s2`Â intoÂ `&s2[..]`.
	- We can see in the signature thatÂ `add`Â takes ownership ofÂ `self`, becauseÂ `self`Â doesÂ _not_Â have anÂ `&`. This meansÂ `s1`Â will be moved into theÂ `add`Â call and will no longer be valid.

```rust
fn main() {
    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

	let s = s1 + "-" + &s2 + "-" + &s3;
    let s = format!("{s1}-{s2}-{s3}");
}

```
- For more complicated string combining, we can instead use theÂ `format!`Â macro.
- TheÂ `format!`Â macro works likeÂ `println!`, but instead of printing the output to the screen, it returns aÂ `String`Â with the contents.

### Indexing
```rust
fn main() {
	let hello = "Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ";
	let answer = &hello[0]; // the type `String` cannot be indexed by `{integer}`

    let s1 = String::from("hello");
    let h = s1[0];
}
```

> If you try to access parts of aÂ `String`Â using indexing syntax in Rust, youâ€™ll get an error. Rust strings donâ€™t support indexing.

- The length of `Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ` is 24 (bytes) in Rust because each Unicode scalar value in that string takes 2 bytes of storage.
- When encoded in UTF-8, the first byte ofÂ `Ğ—`Â isÂ `208`Â and the second isÂ `151`, so it would seem thatÂ `answer`Â should in fact beÂ `208`, butÂ `208`Â is not a valid character on its own.

- There are actually three relevant ways to look at strings from Rustâ€™s perspective: as bytes, scalar values, and grapheme clusters.
	- Take the Hindi word â€œà¤¨à¤®à¤¸à¥à¤¤à¥‡â€ for example.
	- Vector: `[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164, 224, 165, 135]`. Thatâ€™s 18 bytes and is how computers ultimately store this data.
	- Unicode scalar: `['à¤¨', 'à¤®', 'à¤¸', 'à¥', 'à¤¤', 'à¥‡']`. There are sixÂ `char`Â values here, but the fourth and sixth are not letters: theyâ€™re diacritics.
	- Grapheme cluster: `["à¤¨", "à¤®", "à¤¸à¥", "à¤¤à¥‡"]`

```rust
let hello = "Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ";
let s = &hello[0..4];
```
- If you really need to use indices to create string slices, therefore, Rust asks you to be more specific. You can useÂ `[]`Â with a range to create a string slice.

> If we were to try to slice only part of a characterâ€™s bytes with something likeÂ `&hello[0..1]`, Rust would panic at runtime

###  Iterating Over Strings

The best way to operate on pieces of strings is to be explicit about whether you want characters or bytes.

- For individual Unicode scalar values, use theÂ `chars`Â method.

```rust
for c in "à¤¨à¤®à¤¸à¥à¤¤à¥‡".chars() {
    println!("{}", c); // à¤¨ à¤® à¤¸ à¥ à¤¤ à¥‡
}

for b in "à¤¨à¤®à¤¸à¥à¤¤à¥‡".bytes() {
	println!("{}", b); // 224 164 ... 165 135
}
```

- Getting grapheme clusters from strings is complex, so this functionality is not provided by the standard library.

> Remember that valid Unicode scalar values may be made up of more than 1 byte.

## HashMaps
```rust
fn main() {
    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);
}
```

- One way to create an empty hash map is usingÂ `new`Â and adding elements withÂ `insert`.
- Like vectors, hash maps store their data on the **heap**.
- Like vectors, hash maps are homogeneous: all of the keys must have the same type, and all of the values must have the same type.
- For owned values, the values will be moved and the hash map will be the owner of those values

```rust
fn main() {
    use std::collections::HashMap;

    let teams = vec![String::from("Blue"), String::from("Yellow")];
    let initial_scores = vec![10, 50];

    let mut scores: HashMap<_, _> =
        teams.into_iter().zip(initial_scores.into_iter()).collect();
}
```

- Another way of constructing a hash map is by using iterators and theÂ `collect`Â method on a vector of tuples.
- We could use theÂ `zip`Â method to create an iterator of tuples where â€œBlueâ€ is paired with 10.

```rust
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

let team_name = String::from("Blue");
let score = scores.get(&team_name);

for (key, value) in &scores {
	println!("{}: {}", key, value);
}
```

- The `get` result is wrapped inÂ `Some`Â becauseÂ `get`Â returns anÂ `Option<&V>`. If thereâ€™s no value for that key in the hash map,Â `get`Â will returnÂ `None`.

```rust
fn main() {
    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Blue"), 25);

	scores.entry(String::from("Yellow")).or_insert(50);
	scores.entry(String::from("Blue")).or_insert(50);
}
```

- When you want to change the data in a hash map, you have to decide how to handle the case when a key already has a value assigned.
	- You could replace the old value with the new value, completely disregarding the old value.
	- You could keep the old value and ignore the new value

- Hash maps have a special API for this calledÂ `entry`Â that takes the key you want to check as a parameter. The return value of theÂ `entry`Â method is an enum calledÂ `Entry`Â that represents a value that might or might not exist.
- TheÂ `or_insert`Â method onÂ `Entry`Â is defined to return a mutable reference to the value for the correspondingÂ `Entry`Â key if that key exists.

```rust
fn main() {
    use std::collections::HashMap;

    let text = "hello world wonderful world";

    let mut map = HashMap::new();

    for word in text.split_whitespace() {
        let count = map.entry(word).or_insert(0);
        *count += 1;
    }

    println!("{:?}", map);
}
```

- Another common use case for hash maps is to look up a keyâ€™s value and then update it based on the old value.
- In order to assign to that value, we must first dereferenceÂ `count`Â using the asterisk (`*`).


# Closure

Rustâ€™s closures are anonymous functions you can save in a variable or pass as arguments to other functions. You can create the closure in one place and then call the closure elsewhere to evaluate it in a different context. 

> Unlike functions, closures can capture values from the scope in which theyâ€™re defined

```rust
let expensive_closure = |num: u32| -> u32 {
	println!("calculating slowly...");
	thread::sleep(Duration::from_secs(2));
	num
};
```

```rust
fn  add_one_v1   (x: u32) -> u32 { x + 1 }
let add_one_v2 = |x: u32| -> u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
```

- Closures donâ€™t usually require you to annotate the types of the parameters or the return value likeÂ `fn`Â functions do. For closure definitions, the compiler will infer one concrete type for each of their parameters and for their return value

- Closures are typically short and relevant only within a narrow context rather than in any arbitrary scenario. Within these limited contexts, the compiler can infer the types of the parameters and the return type

## Capturing References or Moving Ownership

Closures can capture values from their environment in three ways, which directly map to the three ways a function can take a parameter: borrowing immutably, borrowing mutably, and taking ownership.

```rust
fn main() {
    let list = vec![1, 2, 3];
    println!("Before defining closure: {:?}", list);

    let only_borrows = || println!("From closure: {:?}", list);

    println!("Before calling closure: {:?}", list);
    only_borrows();
    println!("After calling closure: {:?}", list);
}
```

- Because we can have multiple immutable references toÂ `list`Â at the same time,Â `list`Â is still accessible from the code before the closure definition, after the closure definition but before the closure is called, and after the closure is called.

```rust
fn main() {
    let mut list = vec![1, 2, 3];
    println!("Before defining closure: {:?}", list);

    let mut borrows_mutably = || list.push(7);

    borrows_mutably();
    println!("After calling closure: {:?}", list);
}
```

- WhenÂ `borrows_mutably`Â is defined, it captures a mutable reference toÂ `list`. We donâ€™t use the closure again after the closure is called, so the mutable borrow ends.

```rust
use std::thread;

fn main() {
    let list = vec![1, 2, 3];
    println!("Before defining closure: {:?}", list);

    thread::spawn(move || println!("From thread: {:?}", list))
        .join()
        .unwrap();
}
```

- If you want to force the closure to take ownership of the values it uses in the environment even though the body of the closure doesnâ€™t strictly need ownership, you can use theÂ `move`Â keyword before the parameter list.

## Moving Captured Values Out of Closures

A closure body can do any of the following: move a captured value out of the closure, mutate the captured value, neither move nor mutate the value, or capture nothing from the environment to begin with.

- Closures will automatically implement one, two, or all three of theseÂ `Fn`Â traits, in an additive fashion, depending on how the closureâ€™s body handles the values:
	1.  `FnOnce`Â applies to closures that can be called once. All closures implement at least this trait, because all closures can be called. A closure that moves captured values out of its body will only implementÂ `FnOnce`Â and none of the otherÂ `Fn`Â traits, because it can only be called once.
	2.  `FnMut`Â applies to closures that donâ€™t move captured values out of their body, but that might mutate the captured values. These closures can be called more than once.
	3.  `Fn`Â applies to closures that donâ€™t move captured values out of their body and that donâ€™t mutate captured values, as well as closures that capture nothing from their environment. These closures can be called more than once without mutating their environment, which is important in cases such as calling a closure multiple times concurrently.

```rust
impl<T> Option<T> {
    pub fn unwrap_or_else<F>(self, f: F) -> T
    where
        F: FnOnce() -> T
    {
        match self {
            Some(x) => x,
            None => f(),
        }
    }
}
```

- Notice that theÂ `unwrap_or_else`Â function has the additional generic type parameterÂ `F`. TheÂ `F`Â type is the type of the parameter namedÂ `f`, which is the closure we provide when callingÂ `unwrap_or_else`.

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    list.sort_by_key(|r| r.width);
    println!("{:#?}", list);
}
```

- The reasonÂ `sort_by_key`Â is defined to take anÂ `FnMut`Â closure is that it calls the closure multiple times: once for each item in the slice. The closureÂ `|r| r.width`Â doesnâ€™t capture, mutate, or move out anything from its environment, so it meets the trait bound requirements.

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut sort_operations = vec![];
    let value = String::from("by key called");

    list.sort_by_key(|r| {
        sort_operations.push(value);
        r.width
    });
    println!("{:#?}", list);
}
```

- This code attempts to do this counting by pushingÂ `value`â€”aÂ `String`Â from the closureâ€™s environmentâ€”into theÂ `sort_operations`Â vector. The closure capturesÂ `value`Â then movesÂ `value`Â out of the closure by transferring ownership ofÂ `value`Â to theÂ `sort_operations`Â vector.
- This closure can be called once; trying to call it a second time wouldnâ€™t work becauseÂ `value`Â would no longer be in the environment to be pushed intoÂ `sort_operations`Â again
``
```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut num_sort_operations = 0;
    list.sort_by_key(|r| {
        num_sort_operations += 1;
        r.width
    });
    println!("{:#?}, sorted in {num_sort_operations} operations", list);
}
```

- ThisÂ works withÂ `sort_by_key`Â because it is only capturing a mutable reference to theÂ `num_sort_operations`Â counter and can therefore be called more than once.

# Iterator

The iterator pattern allows you to perform some task on a sequence of items in turn. An iterator is responsible for the logic of iterating over each item and determining when the sequence has finished.

```rust
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();


for val in v1_iter {
	println!("Got: {}", val);
}
```

- In Rust, iterators areÂ _lazy_, meaning they have no effect until you call methods that consume the iterator to use it up.
- we iterated over an array using aÂ `for`Â loop to execute some code on each of its items. Under the hood this implicitly created and then consumed an iterator,

## `Iterator` Trait and the `next` Method

```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;

    // methods with default implementations elided
}
```

- TheÂ `Iterator`Â trait only requires implementors to define one method: theÂ `next`Â method, which returns one item of the iterator at a time wrapped inÂ `Some`Â and, when iteration is over, returnsÂ `None`.

```rust
    #[test]
    fn iterator_demonstration() {
        let v1 = vec![1, 2, 3];

        let mut v1_iter = v1.iter();

        assert_eq!(v1_iter.next(), Some(&1));
        assert_eq!(v1_iter.next(), Some(&2));
        assert_eq!(v1_iter.next(), Some(&3));
        assert_eq!(v1_iter.next(), None);
    }

```

- The values we get from the calls toÂ `next`Â are immutable references to the values in the vector.
- TheÂ `iter`Â method produces an iterator over immutable references. If we want to create an iterator that takes ownership ofÂ `v1`Â and returns owned values, we can callÂ `into_iter`Â instead ofÂ `iter`

## Consume the Iterator

- TheÂ `Iterator`Â trait has a number of different methods with default implementations provided by the standard library. Some of these methods call theÂ `next`Â method in their definition, which is why youâ€™re required to implement theÂ `next`Â method
- Methods that callÂ `next`Â are calledÂ _consuming adaptors_, because calling them uses up the iterator.

```rust
    #[test]
    fn iterator_sum() {
        let v1 = vec![1, 2, 3];

        let v1_iter = v1.iter();

        let total: i32 = v1_iter.sum();

        assert_eq!(total, 6);
    }
```

## Adapt the Iterator

- _Iterator adaptors_Â are methods defined on theÂ `Iterator`Â trait that donâ€™t consume the iterator.

```rust
    let v1: Vec<i32> = vec![1, 2, 3];

    let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();

    assert_eq!(v2, vec![2, 3, 4]);

```

- `collect` method consumes the iterator and collects the resulting values into a collection data type.

```rust
#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn filters_by_size() {
        let shoes = vec![
            Shoe {
                size: 10,
                style: String::from("sneaker"),
            },
            Shoe {
                size: 13,
                style: String::from("sandal"),
            },
            Shoe {
                size: 10,
                style: String::from("boot"),
            },
        ];

        let in_my_size = shoes_in_size(shoes, 10);

        assert_eq!(
            in_my_size,
            vec![
                Shoe {
                    size: 10,
                    style: String::from("sneaker")
                },
                Shoe {
                    size: 10,
                    style: String::from("boot")
                },
            ]
        );
    }
}
```

- For this example, weâ€™ll use theÂ `filter`Â method that takes a closure. If the closure returnsÂ `true`, the value will be included in the iteration produced byÂ `filter`. If the closure returnsÂ `false`, the value wonâ€™t be included.
- TheÂ `shoes_in_size`Â function takes ownership of a vector of shoes and a shoe size as parameters. It returns a vector containing only shoes of the specified size.
- In the body ofÂ `shoes_in_size`, we callÂ `into_iter`Â to create an iterator that takes ownership of the vector. Then we callÂ `filter`Â to adapt that iterator into a new iterator that only contains elements for which the closure returnsÂ `true`.

# Macro

- The termÂ _macro_Â refers to a family of features in Rust:Â _declarative_Â macros withÂ `macro_rules!`Â and three kinds ofÂ _procedural_Â macros:
	-  CustomÂ `#[derive]`Â macros that specify code added with theÂ `derive`Â attribute used on structs and enums
	-  Attribute-like macros that define custom attributes usable on any item
	-  Function-like macros that look like function calls but operate on the tokens specified as their argument

- Fundamentally, macros are a way of writing code that writes other code, which is known asÂ _metaprogramming_. Metaprogramming is useful for reducing the amount of code you have to write and maintain.
	- The downside to implementing a macro instead of a function is that macro definitions are more complex than function definitions because youâ€™re writing Rust code that writes Rust code.

- A function signature must declare the number and type of parameters the function has. Macros, on the other hand, can take a variable number of parameters
- Another important difference between macros and functions is that you must define macros or bring them into scopeÂ _before_Â you call them in a file, as opposed to functions you can define anywhere and call anywhere.

## Declarative Macros

The most widely used form of macros in Rust is theÂ _declarative macro_. These are also sometimes referred to as â€œmacros by example,â€ â€œ`macro_rules!`Â macros,â€ or just plain â€œmacros.â€

```rust
#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}

let v: Vec<u32> = vec![1, 2, 3];
```

- TheÂ `#[macro_export]`Â annotation indicates that this macro should be made available whenever the crate in which the macro is defined is brought into scope. Without this annotation, the macro canâ€™t be brought into scope.
- We then start the macro definition withÂ `macro_rules!`Â and the name of the macro weâ€™re definingÂ _without_Â the exclamation mark.
- Here we have one arm with the patternÂ `( $( $x:expr ),* )`, followed byÂ `=>`Â and the block of code associated with this pattern. If the pattern matches, the associated block of code will be emitted.

> More complex macros will have more than one arm.

- We use a set of parentheses to encompass the whole pattern. We use a dollar sign (`$`) to declare a variable in the macro system that will contain the Rust code matching the pattern.
- Next comes a set of parentheses that captures values that match the pattern within the parentheses for use in the replacement code.
	- WithinÂ `$()`Â isÂ `$x:expr`, which matches any Rust expression and gives the expression the nameÂ `$x`.
- The comma followingÂ `$()`Â indicates that a literal comma separator character could optionally appear after the code that matches the code inÂ `$()`
- TheÂ `*`Â specifies that the pattern matches zero or more of whatever precedes theÂ `*`.
	- When we call this macro withÂ `vec![1, 2, 3];`, theÂ `$x`Â pattern matches three times with the three expressionsÂ `1`,Â `2`, andÂ `3`.

## `derive` 

```rust
pub trait HelloMacro {
    fn hello_macro();
}

use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!("Hello, Macro! My name is Pancakes!");
    }
}

fn main() {
    Pancakes::hello_macro();
}
```

- Rather than making our users implement theÂ `HelloMacro`Â trait for each of their types, weâ€™ll provide a procedural macro so users can annotate their type withÂ `#[derive(HelloMacro)]`Â to get a default implementation of theÂ `hello_macro`Â function.

```rust
use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}
```

- Procedural macros need to be in their own crate. Eventually, this restriction might be lifted. The convention for structuring crates and macro crates is as follows: for a crate namedÂ `foo`, a custom derive procedural macro crate is calledÂ `foo_derive`.

## Attributes

Procedural macros accept some code as an input, operate on that code, and produce some code as an output rather than matching against patterns and replacing the code with other code as declarative macros do.

- Attribute-like macros are similar to custom derive macros, but instead of generating code for theÂ `derive`Â attribute, they allow you to create new attributes.

```rust
#[route(GET, "/")]
fn index() {
```

```rust
#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {
```

- ThisÂ `#[route]`Â attribute would be defined by the framework as a procedural macro.
- We have two parameters of typeÂ `TokenStream`. The first is for the contents of the attribute: theÂ `GET, "/"`Â part. The second is the body of the item the attribute is attached to: in this case,Â `fn index() {}`Â and the rest of the functionâ€™s body.

## Function-like macros

Function-like macros define macros that look like function calls. Similarly toÂ `macro_rules!`Â macros, theyâ€™re more flexible than functions;

- Function-like macros take aÂ `TokenStream`Â parameter and their definition manipulates thatÂ `TokenStream`Â using Rust code as the other two types of procedural macros do.

```rust
let sql = sql!(SELECT * FROM posts WHERE id=1);
```

- This macro would parse the SQL statement inside it and check that itâ€™s syntactically correct, which is much more complex processing than aÂ `macro_rules!`Â macro can do.