# Struct

A _struct_, or _structure_, is a custom data type that lets you package together and name multiple related values


```rust
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

```

- To define a struct, we enter the keyword `struct` and name the entire struct.
- Inside curly brackets, we define the names and types of the pieces of data, which we call _fields_.

> It’s also possible for structs to store references to data owned by something else, but to do so requires the use of _lifetimes_

```rust
fn main() {
    let mut user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };
}
```

- To use a struct after we’ve defined it, we create an _instance_ of that struct by specifying concrete values for each of the fields
- We don’t have to specify the fields in the same order in which we declared them in the struct.

```rust
user1.email = String::from("anotheremail@example.com");
```

- To get a specific value from a struct, we use dot notation. For example, `user1.email`
- If the instance is mutable, we can change a value by using the dot notation and assigning into a particular field

> The entire instance must be mutable; Rust doesn’t allow us to mark only certain fields as mutable.


## Field Shorthand

```rust
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn build_user(email: String, username: String) -> User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}

fn main() {
    let user1 = build_user(
        String::from("someone@example.com"),
        String::from("someusername123"),
    );
}
```

- We can use the _field init shorthand_ syntax by which we doesn’t have to  repeat `email` and `username`

## Creating Instances From Other Instances 


```rust
let user2 = User {
	email: String::from("another@example.com"),
	..user1
};
```

- The syntax `..` specifies that the remaining fields not explicitly set should have the same value as the fields in the given instance.
- In this example, we can no longer use `user1` after creating `user2` because the `String` in the `username` field of `user1` was moved into `user2`. If we had given `user2` new `String` values for both `email` and `username`, and thus only used the `active` and `sign_in_count` values from `user1`, then `user1` would still be valid

## Tuple Structs 

```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}
```

- Tuple structs have the added meaning the struct name provides but don’t have names associated with their fields
	- Tuple structs are useful When naming each field as in a regular struct would be verbose or redundant.

- Each struct you define is its own type, even though the fields within the struct have the same types.
- You can use a `.` followed by the index to access an individual value

## Unit-Like Structs

```rust
struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}
```

- You can define structs that don’t have any fields. These are called _unit-like structs_ because they behave similarly to `()`
	- Unit-like structs can be useful when you need to implement a trait on some type but don’t have any data that you want to store in the type itself.
- To create unit-like struct, there is no need for curly brackets or parentheses

# Struct Method


```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}
```

- To define the function within the context of `Rectangle`, we start an `impl` (implementation) block for `Rectangle`.
- The method syntax goes after an instance: we add a dot followed by the method name, parentheses, and any arguments.
- In the signature for `area`, we use `&self` instead of `rectangle: &Rectangle`. The `&self` is actually short for `self: &Self`.
	- The type `Self` is an alias for the type that the `impl` block is for
	- Methods must have a parameter named `self` of type `Self` for their first parameter
- We’ve chosen `&self` here for the reason: we don’t want to take ownership, and we just want to read the data in the struct, not write to it.
- If we wanted to change the instance that we’ve called the method on as part of what the method does, we’d use `&mut self` as the first parameter


```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn width(&self) -> bool {
        self.width > 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    if rect1.width() {
        println!("The rectangle has a nonzero width; it is {}", rect1.width);
    }
}

```

- Rust knows we mean the method `width`. When we don’t use parentheses, Rust knows we mean the field `width`.

>  Rust has a feature called _automatic referencing and dereferencing_. When you call a method with `object.something()`, Rust automatically adds in `&`, `&mut`, or `*` so `object` matches the signature of the method.

# Enum
Enums are a way of defining custom data types in a different way than you do with struct.


```rust
enum IpAddrKind {
    V4,
    V6,
}

fn main() {
    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;

    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
}

fn route(ip_kind: IpAddrKind) {}

```

- The variants of the enum are namespaced under its identifier, and we use a double colon to separate the two, such as `IpAddrKind::V4`.

```rust
fn main() {
    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from("::1"));
}

```

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}


impl Message {
	fn call(&self) {
		// method body would be defined here
	}
}

let m = Message::Write(String::from("hello"));
m.call();

```
- We can put data directly into each enum variant.
- The name of each enum variant that we define also becomes a function that constructs an instance of the enum.

# Option

`Option` is another enum defined by the standard library. The `Option` type encodes the very common scenario in which a value could be something or it could be nothing.

```rust

enum Option<T> {
    None,
    Some(T),
}
```

- Rust does not have nulls, but it does have an enum that can encode the concept of a value being present or absent.

```rust
fn main() {
    let some_number = Some(5);
    let some_string = Some("a string");

    let absent_number: Option<i32> = None;
}

```
- You can use `Some` and `None` directly without the `Option::`
- Rust requires us to annotate the overall `Option` type: the compiler can’t infer the type that the corresponding `Some` variant will hold by looking only at a `None` value.
- Rust requires us to annotate the overall `Option` type: the compiler can’t infer the type that the corresponding `Some` variant will hold by looking only at a `None` value.
- `Option<T>` and `T` are different type. In other words, you have to convert an `Option<T>` to a `T` before you can perform `T` operations with it.

```rust
fn main() {
    fn plus_one(x: Option<i32>) -> Option<i32> {
        match x {
            None => None,
            Some(i) => Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
}
```

- We can also handle `Option<T>` using `match` as we did with the `Coin` enum