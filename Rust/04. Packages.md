# Packages and Crates

- A _package_ is one or more crates that provide a set of functionality.
	- A package contains a _Cargo.toml_ file that describes how to build those crates.

- Several rules determine what a package can contain.
	- A package can contain at most one library crate.
	- It can contain as many binary crates as you’d like
	- It must contain at least one crate

- A _crate_ can be a binary crate or a library crate.
	- _Binary crates_ are programs you can compile to an executable that you can run, such as a command-line program or a server. They must have a function called `main` that defines what happens when the executable runs.
	- _Library crates_ don’t have a `main` function, and they don’t compile to an executable. They define functionality intended to be shared with multiple projects.

- The _crate root_ is a source file that the Rust compiler starts from and makes up the root module of your crate

- `cargo new [project]` created a `Cargo.toml` file, giving us a package.
	- There’s no mention of `src/main.rs` because Cargo follows a convention that _src/main.rs_ is the crate root of a binary crate
	- Cargo knows that if the package directory contains `src/lib.rs`, _src/lib.rs_ is its crate root.

# Modules

```
backyard
├── Cargo.lock
├── Cargo.toml
└── src
    ├── garden
    │   └── vegetables.rs
    ├── garden.rs
    └── main.rs
```

```rust
use crate::garden::vegetables::Asparagus;

pub mod garden;

fn main() {
    let plant = Asparagus {};
    println!("I'm growing {:?}!", plant);
}
```

```rust
// src/garden.rs
pub mod vegetables;
```

```rust
// src/garden/vegetables.r

#[derive(Debug)]
pub struct Asparagus {}
```

- The `use` keyword that brings a path into scope
- The `pub` keyword to make items public.


- In the crate root file, you can declare a new module named, say, “garden”, with `mod garden;` The compiler will look for the code inside the module in these places:
	- Inline, directly following `mod garden`, within curly brackets instead of the semicolon
	- In the file _src/garden.rs_
	- In the file _src/garden/mod.rs_

- In any file other than the crate root that’s being compiled as part of the crate (for example, _src/garden.rs_), you can declare submodules (for example, `mod vegetables;`)
	- Inline, directly following `mod vegetables`, within curly brackets instead of the semicolon
	- In the file _src/garden/vegetables.rs_
	- In the file _src/garden/vegetables/mod.rs_

- Once a module is being compiled as part of your crate, you can refer to code in that module from anywhere else in this crate by using the path `crate::garden::vegetables::Asparagus` as long as the privacy rules allow.

- To make a module public, declare it with `pub mod` instead of `mod`. To make items within a public module public as well, use `pub` before their declarations.
- Within a scope, the `use` keyword creates shortcuts to items to reduce repetition of long paths. In any scope that can refer to `crate::garden::vegetables::Asparagus`, you can create a shortcut with `use crate::garden::vegetables::Asparagus;` and then only need to write `Asparagus` to make use of that type in the scope.

## Grouping

```rust
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}

```


- Modules can also hold definitions for other items, such as modules, structs, enums, constants, traits, and functions.
- If module A is contained inside module B, we say that module A is the _child_ of module B and that module B is the _parent_ of module A.

```
crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment

```

- The entire module tree is rooted under the implicit module named `crate`.

## mod

- We use a path in the same way we use a path when navigating a filesystem.
	- An _absolute path_ starts from a crate root by using a crate name
	- A _relative path_ starts from the current module and uses `self`, `super`, or an identifier in the current module.

```rust
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist(); // rror[E0603]: module `hosting` is private

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
```

- After `crate`, we include each of the successive modules until we make our way to `add_to_waitlist`
- The second time we call `add_to_waitlist`, we use a relative path. The path starts with `front_of_house`, the name of the module defined at the same level of the module tree as `eat_at_restaurant`.

> Our preference is to specify absolute paths because it’s more likely we’ll want to move code definitions and item calls independently of each other.


```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
```

- Modules define Rust’s _privacy boundary_: the line that encapsulates the implementation details external code isn’t allowed to know about, call, or rely on.

- In Rust is that all items (functions, methods, structs, enums, modules, and constants) are private by default
- Items in a parent module can’t use the private items inside child modules, but items in child modules can use the items in their ancestor modules.

### Relative Paths with super

```rust
fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::deliver_order();
    }

    fn cook_order() {}
}
```

- The `fix_incorrect_order` function is in the `back_of_house` module, so we can use `super` to go to the parent module of `back_of_house`, which in this case is `crate`

### Public Structs and Enums 

We use `pub` before a struct definition, we make the struct public, but the struct’s fields will still be private.


```rust
mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &str) -> Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("peaches"),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // Order a breakfast in the summer with Rye toast
    let mut meal = back_of_house::Breakfast::summer("Rye");
    // Change our mind about what bread we'd like
    meal.toast = String::from("Wheat");
    println!("I'd like {} toast please", meal.toast);

    // The next line won't compile if we uncomment it; we're not allowed
    // to see or modify the seasonal fruit that comes with the meal
    // meal.seasonal_fruit = String::from("blueberries");
}

```

- Because `back_of_house::Breakfast` has a private field, the struct needs to provide a public associated function that constructs an instance of `Breakfast`. `Breakfast` didn’t have such a function, we couldn’t create an instance of `Breakfast`

```rust
mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}
```

- In contrast, if we make an enum public, all of its variants are then public.

## use

It might seem like the paths we’ve written to call functions so far are inconveniently long and repetitive

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}


pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}

```

- We can create a shortcut to a path with the `use` keyword once, and then use the shorter name everywhere else in the scope.
- `use` only creates the shortcut for the particular scope in which the `use` occurs.

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
}

```

- Specifying the parent module when calling the function makes it clear that the function isn’t locally defined while still minimizing repetition of the full path.
- On the other hand, when bringing in structs, enums, and other items with `use`, it’s idiomatic to specify the full path.
	- The exception to this idiom is if we’re bringing two items with the same name into scope

```rust
use rand::Rng;

// --snip--
// use std::cmp::Ordering;
// use std::io;
use std::{cmp::Ordering, io};
// --snip--

// use std::io;
// use std::io::Write;
use std::io::{self, Write};
```

- We can use nested paths to bring the same items into scope in one line
- In bigger programs, bringing many items into scope from the same crate or module using nested paths can reduce the number of separate `use` statements.
- We can use a nested path at any level in a path

```rust
use std::collections::*;
```

- If we want to bring _all_ public items defined in a path into scope, we can specify that path followed by `*`, the glob operator.

## as 

There’s another solution to the problem of bringing two types of the same name into the same scope with `use`


```rust
use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -> Result {
    // --snip--
    Ok(())
}

fn function2() -> IoResult<()> {
    // --snip--
    Ok(())
}
```


## pub use

When we bring a name into scope with the `use` keyword, the name available in the new scope is private. To enable the code that calls our code to refer to that name as if it had been defined in that code’s scope, we can combine `pub` and `use`. This technique is called _re-exporting_


```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
```

- Re-exporting is useful when the internal structure of your code is different from how programmers calling your code would think about the domain

# External Package

```
rand = "0.8.3"
```

- Adding `rand` as a dependency in _Cargo.toml_ tells Cargo to download the `rand` package and any dependencies from [crates.io](https://crates.io/) and make `rand` available to our project.

```rust
use std::io;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..101);

    println!("The secret number is: {}", secret_number);

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
```

- To bring `rand` definitions into the scope of our package, we added a `use` line starting with the name of the crate.
- Members of the Rust community have made many packages available at [crates.io](https://crates.io/), and pulling any of them into your package involves these same steps
- `std`is also a crate that’s external to our package. Because the standard library is shipped with the Rust language, we don’t need to change _Cargo.toml_ to include `std`

## Modules Separation

When modules get large, you might want to move their definitions to a separate file to make the code easier to navigate.


- For a module named `front_of_house` declared in the crate root, the compiler will look for the module’s code in:
	- _src/front_of_house.rs_ (what we covered)
	- _src/front_of_house/mod.rs_ (older, still supported path)

- For a module named `hosting` that is a submodule of `front_of_house`, the compiler will look for the module’s code in:
	- _src/front_of_house/hosting.rs_ (what we covered)
	- _src/front_of_house/hosting/mod.rs_ (older, still supported path)

> If you use both for the same module, you’ll get a compiler error.