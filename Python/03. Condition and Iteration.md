# Condition
```python
if expression : 
   suite
elif expression : 
   suite 
else : 
   suite
```
- Header lines begin the statement and terminate with a colon ( `:` ) and are followed by one or more lines which make up the suite.
- Python programming language assumes any non-zero and non-null values as `true`.
```python
#!/usr/bin/python

var = 100
if ( var == 100 ) : print "Value of expression is 100"
print "Good bye!"
```
- If the suite of an if clause consists only of a single line, it may go on the same line as the header statement.
```python
if (n := len(a)) > 10:
    print(f"List is too long ({n} elements, expected <= 10)")
```
- `:=` that assigns values to variables as part of a larger expression.

# Structural Pattern Matching¶

There is not `switch-case` pattern for Python. However, after Python `3.10.0`, structural pattern Matching has been added in the form of a `match` statement and `case` statements.

- The generic syntax of pattern matching is:

  ```python
  def http_error(status):
    match status:
        case 400:
            return "Bad request"
        case 401 | 403:
          return "Not allowed"
        case 404:
            return "Not found"
        case 418:
            return "I'm a teapot"
        case _:
            return "Something's wrong with the internet"
  ```

  - `_` will match as a wildcard. The use of `_` is optional.
  -  You can combine several literals in a single pattern using `|`:

## Builtin Matching

```python
# point is an (x, y) tuple
match point:
    case (0, 0):
        print("Origin")
    case (0, y):
        print(f"Y={y}")
    case (x, 0):
        print(f"X={x}")
    case (x, y):
        print(f"X={x}, Y={y}")
    case _:
        raise ValueError("Not a point")
```

- Patterns can look like unpacking assignments, and a pattern may be used to bind variables.

- Sequence patterns support wildcards: `[x, y, *rest]` and `(x, y, *rest)`. The name after `*` may also be `_`, so `(x, y, *_)` matches a sequence of at least two item.
- Mapping patterns: `{"bandwidth": b, "latency": l}` captures the "`bandwidth`" and "`latency`" values from a dict. Unlike sequence patterns, **extra keys are ignored**. A wildcard `**rest` is also supported

## Class Matching

```python
class Point:
    x: int
    y: int

def location(point):
    match point:
        case Point(x=0, y=0):
            print("Origin is the point's location.")
        case Point(x=0, y=y):
            print(f"Y={y} and the point is on the y-axis.")
        case Point(x=x, y=0):
            print(f"X={x} and the point is on the x-axis.")
        case Point():
            print("The point is located somewhere else on the plane.")
        case _:
            print("Not a point")
```

- If you are using classes to structure your data, you can use as a pattern the class name followed by an argument list resembling a constructor.

# Complex patterns 

```python
match points:
    case []:
        print("No points in the list.")
    case [Point(0, 0)]:
        print("The origin is the only point in the list.")
    case [Point(x, y)]:
        print(f"A single point {x}, {y} is in the list.")
    case [Point(0, y1), Point(0, y2)]:
        print(f"Two points on the Y axis at {y1}, {y2} are in the list.")
    case _:
        print("Something else is found in the list.")
```

- Patterns can be arbitrarily nested.

```python
match test_variable:
    case ('warning', code, 40):
        print("A warning has been received.")
    case ('error', code, _):
        print(f"An error {code} occurred.")
```

- A wildcard can be used in more complex pattern.

## Guard

We can add an if clause to a pattern, known as a “guard”. If the guard is false, match goes on to try the next case block. 

```python
match point:
    case Point(x, y) if x == y:
        print(f"The point is located on the diagonal Y=X at {x}.")
    case Point(x, y):
        print(f"Point is not on the diagonal.")
```

# Iteration
- `while`
  ```python
  #!/usr/bin/python

  count = 0
  while (count < 9):
    print 'The count is:', count
    count = count + 1

  print "Good bye!"
  ```
  - A `while` loop statement in Python programming language repeatedly executes a target statement as long as a given condition is `true`.
  ```python
  #!/usr/bin/python

  count = 0
  while count < 5:
    print count, " is  less than 5"
    count = count + 1
  else:
    print count, " is not less than 5"
  ``` 
  - If the `else` statement is used with a while loop, the `else` statement is **executed when the condition becomes false**.
- `for`
  ```python
  #!/usr/bin/python

  for letter in 'Python':     # First Example
    print 'Current Letter :', letter

  fruits = ['banana', 'apple',  'mango']
  for fruit in fruits:        # Second Example
    print 'Current fruit :', fruit

  print "Good bye!"
  ```
  - `for` has the ability to **iterate over the items of any sequence**, such as a list or a string.
  ```python
  #!/usr/bin/python

  fruits = ['banana', 'apple',  'mango']
  for index in range(len(fruits)):
    print 'Current fruit :', fruits[index]

  print "Good bye!"
  ``` 
  - Use `range(start[, end])` to generate a number array that could be seemed as an index.
  ```python
  #!/usr/bin/python

  for num in range(10,20):     #to iterate between 10 to 20
    for i in range(2,num):    #to iterate on the factors of the number
      if num%i == 0:         #to determine the first factor
        j=num/i             #to calculate the second factor
        print '%d equals %d * %d' % (num,i,j)
        break #to move to the next number, the #first FOR
    else:                  # else part of the loop
      print num, 'is a prime number'
  ``` 
  - If the else statement is used with a for loop, the else statement is executed **when the loop has exhausted iterating the list**.

- Loop control
  - `break`
    - It terminates the current loop and resumes execution at the next statement
    - The most common use for `break` is when some external condition is triggered requiring a hasty exit from a loop.
  - `continue`
    - It returns the control to the beginning of the while loop
  - `pass`
    ```python
    #!/usr/bin/python

    for letter in 'Python': 
      if letter == 'h':
        pass
        print 'This is pass block'
      print 'Current Letter :', letter

    print "Good bye!"
    ```
    - The `pass` statement is a null operation; **nothing happens** when it executes.
    - The `pass` is also useful in places where your code will eventually go, but has not been written yet.