## Structure
- `struct` is an aggregate of elements of **arbitrary types**. On the other hand, array is an aggregate of elements of the same type.
- Objects of structure types can be assigned, passed as function arguments, and returned as the result from a function.
```C++
struct Address {
  const char∗ name;
  int number;
  const char∗ street;
  const char∗ town;
  char state[2];
  const char∗ zip;
};

void f()
{
  Address jd = {
      "Jim Dandy",
      61,
      "South St",
      "New Providence",
      {'N','J'},
      "07974"
  };
  jd.name = "Jim Dandy";
  jd.number = 61;
}
``` 
- Note the **terminating semicolon**.
- `struct` types can be initialized using the `{}` notation
- The individual members can be accessed using the `.` operator.
```C++
void print_addr(Address∗ p)
{
  cout << p−>name << '\n'
      << p−>number << ' ' << p−>street << '\n'
      << p−>town << '\n'
      << p−>state[0] << p−>state[1] << ' ' << p−>zip << '\n';
}

void print_addr2(const Address& r)
{
  cout << r.name << '\n'
      << r.number << ' ' << r.street << '\n'
      << r.town << '\n'
      << r.state[0] << r.state[1] << ' ' << r.zip << '\n';
}
``` 
- Structures accessed **through pointers** use the `−>` (`struct` pointer dereference) operator.
- When `p` is a pointer, `p−>m` is equivalent to `(∗p).m`.
- `struct` can be passed **by reference** and accessed using the `.`.
***
- Layout
  ```C++
  struct Readout {
      char hour;
      int value;
      char seq;
  };
  ``` 
  ![Struct Layout](images/StructLayout.png)
  - Members are allocated in memory in declaration order.
  - Since objects are properly **aligned**, the size of an object of a struct is not necessarily the sum of the sizes of its members. There are "hole" in the structures.
  - In this case, as on many machines, `sizeof(Readout)` is `12` rather than `6`.
  ```C++
  struct Readout {
    int value;
    char hour;
    char seq;
  };
  ``` 
  ![Struct Layout 2](images/StructLayout2.png)
  - **Minimize wasted space by simply ordering members by size** (largest member first).
  - This still leaves a 2-byte "hole" and `sizeof(Readout)==8`.
  - It is usually **best to order members for readability** and sort them by size **only if there is a demonstrated need to optimize.**
  - Use of multiple access specifiers (i.e., public, private, or protected) can affect layout.
***
- Names
  ```C++
  struct Link {
    Link∗ previous;  // OK
    Link∗ successor;
  };

  struct No_good {
    No_good member; // error: recursive deﬁnition
  };
  ``` 
  - The name of a type becomes available immediately after it has been encountered.
  - However, **it is not possible to declare new objects of a struct until its complete declaration** because the compiler is not able to determine the size.
  - Pointer doesn't need to know the size of a type.
  ```C++
  struct List; // struct name declaration: List to be deﬁned later

  struct Link { 
    Link∗ pre;
    Link∗ suc;
    List∗ member_of;
    int data;
  };

  struct List {
    Link∗ head;
  };
  ``` 
  - To allow two structs to refer to each other, we can declare a name to be the name of a struct.
  ```C++
  struct S; // ‘‘S’’ is the name of some type

  extern S a;
  S f();
  void g(S);
  S∗ h(S∗);

  void k(S∗ p)
  {
    S a;  // error: S not deﬁned; size needed to allocate

    f(); // error: S not deﬁned; size needed to return value
    g(a); // error: S not deﬁned; size needed to pass argument
    p−>m = 7; // error: S not deﬁned; member name not known
    
    S∗ q = h(p); // ok: pointers can be allocated and passed
    q−>m = 7; // error: S not deﬁned; member name not known
  }
  ``` 
  - Until the completion of the declaration of a struct, that struct is an incomplete type,.
***
- Structures and Classes
  - A `struct` is simply a class where the members are public by default.
  - a `struct` can have **member functions and constructors** as well.
  ```C++
  struct Point { int x, y; };

  Point p0; // danger: uninitialized if in local scope
  Point p1 {}; // default construction: {{},{}}; that is {0.0} 
  Point p2 {1}; // the second member is default constructed: {1,{}}; that is {1,0}
  Point p3 {1,2}; // {1,2}
  ``` 
  - Default constructors initialize members in order.
  ```C++
  struct Address {
    string name;
    int number;
    string street;
    string town;
    char state[2];
    char zip[5];

    Address(const string n, int nu, const string& s, const string& t, const string& st, int z);
  };

  Address::Address(const string& n, int nu, const string& s, const string& t, const string& st, int z)
    :name{n},
    number{nu},
    street{s},
    town{t}
  {
    if (st.size()!=2)
      error("State abbreviation should be two characters") /
    state = {st[0],st[1]};

    ostringstream ost;
    ost << z;
    string zi {ost.str()};
    switch (zi.size()) {
      case 5:
        zip = {zi[0], zi[1], zi[2], zi[3], zi[4]};
        break;
      case 4: // star ts with ’0’
        zip = {'0', zi[0], zi[1], zi[2], zi[3]};
        break;
      default:
        error("unexpected ZIP code format"); }
    }
    // ...
  }
  ``` 
  - Constructors are needed if you need to reorder arguments, validate arguments, modify arguments, establish invariants, etc.
***
- Equivalence
  - Two `struct`s are different types even when they have the same members.
  - A struct is also a different type from a type used as a member.
  - Every struct must have a unique deﬁnition in a program.
***
- **Plain Old Data** (POD)
  - POD ("Plain Old Data") is an object that can be manipulated as ""just data" **without worrying about complications of class layouts or user-deﬁned semantics for construction, copy, and move.**
  ```C++
  struct S0 { }; // a POD
  struct S1 { int a; };  // a POD 
  struct S2 { int a; S2(int aa) : a(aa) { } }; // not a POD (no default constructor)
  struct S3 { int a; S3(int aa) : a(aa) { } S3() {} }; // a POD (user-deﬁned default constructor)
  struct S4 { int a; S4(int aa) : a(aa) { } S4() = default;}; // a POD
  struct S5 { virtual void f(); /* ... */ }; // not a POD (has a virtual function)

  struct S6 : S1 { }; // a POD
  struct S7 : S0 { int b; }; // a POD
  struct S8 : S1 { int b; };  // not a POD (data in both S1 and S8) 
  struct S9 : S0, S1 {};  // a POD
  ``` 
  - POD must 
    - Is *standard layout type*
      - A type has standard layout unless it
        - has a non-`static` member or a base that is not standard layout
        - has a `virtual` function
        - has a `virtual` base
        - has a member that is a reference
        - has multiple access speciﬁers for non-static data members
        - prevents important layout optimizations
          - by having non-static data members in more than one base class or in both the derived class and a base
          - by having a base class of the same type as the ﬁrst non-static data member.
      - It is is in the union of what common C++ *Application Binary Interfaces (ABIs)* can handle.
    - have standard (not user-deﬁned) copy semantics (*trivially copyable type*)
      - a copy operation is trivial if it can be implemented as a bitwise copy.
      - a copy, move, or destructor is nontrivial if
        - **It is user-deﬁned**.
        - Its class has a `virtual` function.
        - Its class has a `virtual` base.
        - Its class has a base or a member that is not trivial.
    - have a trivial default constructor.
      - a default constructor is **trivial if it does not need to do any work** (use `=default` if you need to deﬁne one).
  ```C++
  template<typename T>
  void mycopy(T∗ to, const T∗ from, int count)
  {
    if (is_pod<T>::value
      memcpy(to,from,count∗sizeof(T));
    else
      for (int i=0; i!=count; ++i)
        to[i]=from[i];
  }
  ``` 
  - The `is_pod` is a standard-library type property predicate deﬁned in `<type_traits>`
***
- Fields
  - We can bundle several such **tiny variables** together as ﬁelds in a struct.
    - A ﬁeld must be of **an integral or enumeration type**.
  - A ﬁeld is often called a bit-ﬁeld.
  - It is not possible to take the address of a ﬁeld.
  - Using ﬁelds to pack several variables into a single byte does not necessarily save space.
  - It is typically much faster to access a char or an int than to access a ﬁeld.
  - Fields are simply a convenient shorthand for using bitwise logical operators to extract information from and insert information into part of a word
  ```C++
  struct PPN { // R6000 Physical Page Number
    unsigned int PFN : 22; // Page Frame Number
    int : 3; // unused unsigned
    int CCA : 3; // Cache Coherency Algorithm 
    bool nonreachable : 1;
    bool dirty : 1;
    bool valid : 1;
    bool global : 1;
  };
  ``` 
  - A member is deﬁned to be a ﬁeld by specifying the number of **bits** it is to occupy.
  - Unnamed ﬁelds are allowed.

## Unions
- A `union` is a struct in which all members are allocated at the same address.
- A `union` can hold a value for **only one member at a time**.
- Unions are sometimes misused for "type conversion." If you need a conversion, use an explicit type conversion operator (`reinterpret_cast<T>`)
- Most programs don’t improve much from the use of `union`s and `union`s are rather error-prone. Thus, **avoid `union` when you can**.
```C++
enum Type { str, num };

struct Entry {
  char* name;
  Type t;
  char* s; // use s if t==str
  int i;  // use i if t==num
};
``` 
- The members `s` and `i` can never be used at the same time, so space is wasted
```C++
union Value {
  char* s;
  int i;
};

struct Entry {
  char∗ name;
  Type t;
  Value v; // use v.s if t==str; use v.i if t==num
};

void f(Entry∗ p) {
  if (p−>t == str)
      cout << p−>v.s;
  }
}
```
- The language doesn’t keep track of which kind of value is held by a `union`.
***
- Unions and Classes