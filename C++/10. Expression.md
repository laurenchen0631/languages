## Desk Calculator
- Requirement
  - Four standard arithmetic operations on ﬂoating-point numbers: `+`, `-`, `*`, `/`
  - The can also define variables.
- The calculator consists of four main parts:
  - Parser: does the syntactic analysis.
  - Input function: handles input and lexical analysis.
  - Symbol table: holds permanent information.
  - Driver: handles initialization, output, and errors.
- Actually, it is a miniature compiler.
***
- Parser
  - Grammar tree
    - program:
      - `end`
      - *expr_list* `end`
    - *expr_list*:
      - *expression* `print`
      - *expression* `print` *expr_list*
    - *expression*:
      - *expression* `+` *term*
      - *expression* `−` *term*
      - *term*
    - *term*:
      - *term* `/` *primary*
      - *term* `*` *primary*
      - *primary*
    - *primary*:
      - number
      - name
      - name `=` *expression*
      - `−`*primary*
      - `(` *expression* `)`
  - The basic units of an expression are numbers, names, and the operators `*`, `/`, `+`, `−` (both unary and binary), and `=` (assignment).
  - Terminal symbols (for example, `end`, number, `+`, and `−`) are recognized by a lexical analyzer
  - Nonterminal symbols are recognized by the **syntax analyzer functions**, `expr()`, `term()`, and `prim()`.
  - For input, the parser uses a `Token_stream` that encapsulates the reading of characters and their composition into `Token`s.
    - To read the **next** Token, it calls `ts.get()`.
    - To get the most recently read, it calls `ts.current()`.

  ```c++
  enum class Kind : char {
    name, number, end,
    plus='+', minus='−', mul='*', div='/’, print=';', assign='=', lp='(', rp=')'
  };

  double expr(bool);

  double prim(bool get) // handle primaries
  {
    if (get) ts.get(); // read next token

    switch (ts.current().kind)
    {
      case Kind::number: // ﬂoating-point constant
      {
        double v = ts.current().number_value;
        ts.get();
        return v;
      }
      case Kind::name:
      {
        double& v = table[ts.current().string_value]; // find the corresponding 
        if (ts.get().kind == Kind::assign) v = expr(true); // ’=’ seen: assignment
        return v;
      }
      case Kind::minus: // unary minus
        return −prim(true);
      case Kind::lp:
      {
        auto e = expr(true);
        if (ts.current().kind != Kind::rp) return error("')' expected");
        ts.get(); // eat ’)’
        return e;
      }
      default:
        return error("primary expected");
    }
  }

  double term(bool get) // multiply and divide
  {
    double left = prim(get);
    
    for (;;) {
      switch (ts.current().kind) {
      case Kind::mul:
        left *= prim(true);
        break;
      case Kind::div:
        if (auto d = prim(true)) {
          left /= d;
          break;
        }
        return error("divide by 0");
      default:
        return left;
      }
    }
  }

  double expr(bool get) // add and subtract
  { 
    double left = term(get);
    
    for (;;) {
      switch (ts.current().kind) { 
        case Kind::plus:
          left += term(true);
          break;
        case Kind::minus:
          left −= term(true);
          break;
        default:
          return left; 
      }
    }
  }
  ``` 
  - It uses a style of syntax analysis called *recursive descent*.
  - As soon as **both operands** of a (sub)expression are known, the expression is evaluated.
  - Each parser function takes a `bool` argument, called `get`, indicating whether the function needs to call `Token_stream::get()` to get the next token.
  - `prim()` is lower in the call hierarchy a bit of real work is being done and no loop is necessary.
  - `prim()` always reads one more Token because it must do that in some cases, so for consistency it must do it in all cases.
  - The symbol table is a `map<string,double> table;`
  - `expr()` calls `term()`, which calls `prim()`, which in turn calls `expr()`. This loop of calls must be broken somehow. Thus, we put `double expr(bool);` before the deﬁnition of prim().
***
- Input
  - The task of a low-level input routine is to read characters and compose higher-level tokens from them.
  ```C++
  struct Token {
    Kind kind;
    string string_value;
    double number_value;
  };

  class Token_stream {
  public:
    Token_stream(istream& s) : ip{&s}, owns{false} { }
    Token_stream(istream* p) : ip{p}, owns{true} { }

    ~Token_stream() { close(); }

    Token get();  // read and return next token 
    Token& current(); // most recently read token

    void set_input(istream& s) { close(); ip = &s; owns=false; }
    void set_input(istream* p) { close(); ip = p; owns = true; }

  private:

    void close() { if (owns) delete ip; }
    
    istream* ip; // pointer to an input stream
    bool owns; // does the Token_stream own the istream?
    Token ct {Kind::end} ; // current token
  };
  ``` 
  - Representing each token by the integer value of its character is convenient and efficient and **can be a help to people using debuggers**.
  - When a Token that is a number, its value is placed in its `number_value`. Similarly, when a Token that is a name, its value is placed in its string_value. 
  - It is a useful and general technique for classes that hold a **pointer (`istream`) to a resource requiring destruction**.
  - People should not call `current()` before `get()`, but if they do, they get a well-default Token.
  ```C++
  Token Token_stream::get()
  {
    char ch = 0;
    *ip>>ch;

    switch (ch) { 
    case 0:
      return ct={Kind::end};  // assign and return

    case ';':  // end of expression; print
    case '*':
    case '/':
    case '+':
    case '−':
    case '(':
    case ')':
    case '=': 
      return ct=={static_cast<Kind>(ch)};
      
    case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': case '.':
      ip−>putback(ch); // put the ﬁrst digit (or .) back into the input stream
      *ip >> ct.number_value; // read number into ct
      ct.kind=Kind::number;
      return ct;
      
    default: // name, name =, or error
      if (isalpha(ch)) {
        ip−>putback(ch); // put the ﬁrst character back into the input stream
        *ip>>ct.string_value; // read string into ct
        ct.kind=Kind::name;
        return ct;
      }
      error("bad token");
      return ct={Kind::print};
    }
  }
  ``` 
  - **By default, operator `>>` skips whitespace** and leaves the value of ch unchanged if the input operation failed.
  - The `static_cast` is needed because there is no implicit conversion from `char` to `Kind`.
  - This `Token_stream::get()` is a simple version that **imposes a burden on the user**.
    - It is tedious to remember to add a semicolon after an expression in order to get its value printed.
    - Having a name terminated by whitespace only is a real nuisance.
  ```c++
  Token Token_stream::get()
  {
    char ch;
    // *ip >> ch;
    
    do { // skip whitespace except ’\n’
      if (!ip−>get(ch)) return ct={Kind::end};
    } while (ch!='\n' && isspace(ch));

    switch (ch) { 
    case ';':
    case '\n':
      return ct={Kind::print};
    case '*':
    case '/':
    case '+':
    case '−':
    case '(':
    case ')':
    case '=': 
      return ct=={static_cast<Kind>(ch)};
      
    case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': case '.':
      ip−>putback(ch); // put the ﬁrst digit (or .) back into the input stream
      *ip >> ct.number_value; // read number into ct
      ct.kind=Kind::number;
      return ct;
      
    default: // name, name =, or error
      // if (isalpha(ch)) {
      //   ip−>putback(ch); // put the ﬁrst character back into the input stream
      //   *ip>>ct.string_value; // read string into ct
      //   ct.kind=Kind::name;
      //   return ct;
      // }
      if (isalpha(ch)) {
        string_value = ch;
        while (ip−>get(ch) && isalnum(ch)) // A*B = 5
          string_value += ch; // append ch to end of string_value
        ip−>putback(ch);
        return ct={Kind::name};
      }
      error("bad token");
      return ct={Kind::print};
    }
  }
  ``` 
  - We make a newline equivalent to the semicolon used to mark the end-of-expression
  - **By default, `get()` does not skip whitespace and newline the way `>>` does**.
  - The standard-library provides several functions to check the character
    - `isspace(c)`: returns a nonzero value if `c` is a whitespace character and zero otherwise.
    - `isdigit()`: test if a character is a digit
    - `isalpha()`: test if a character is a letter
    - `isalnum()`: test if a character is a digit or letter
  - The problem caused by `>>` reading into a string until whitespace is encountered is solved by reading one character at a time until a character that is not a letter or a digit is found
    - Previous `Token_stream::get()` will treat "A*B=5" as a token with a name_string `A*B=5`
    - New `Token_stream::get()` will treat "A*B=5" as five tokens: `A`, `*`, `B`, `=`, and `5`
  - All modern string implementations provide the "small string optimization", so adding characters to the end of a string one by one wouldn't be inefficient.
    - The maximum number of characters for a *short string* is implementation-dependent
    - Usually, string length 14 would be a good guess
***
- Error Handling
  ```C++
  int no_of_errors;

  double error(const string& s) {
    no_of_errors++;
    cerr << "error: " << s << '\n';
    return 1;
  }
  ```
  - It is always important to detect and report errors.
  - The error() function simply counts the errors, writes out an error message, and returns.
  - **The reason for returning** is that errors typically occur in the middle of the evaluation of an expression, so we should either **abort that evaluation entirely** or **return a value that is unlikely to cause subsequent errors**.
***
- The driver
  ```C++
  #include<iostream> // I/O
  #include<sstream> // istringstream
  #include<string> // strings
  #include<map> // map
  #include<cctype> // isalpha(), etc.

  using namespace std;

  Token_stream ts {cin}; // use input from cin

  void calculate()
  {
    for (;;) {
      ts.get();
      if (ts.current().kind == Kind::end) break;
      if (ts.current().kind == Kind::print) continue;
      cout << expr(false) << '\n';
    }
  }

  int main(int argc, char* argv[]) {
    switch (argc) {
    case 1: // read from standard input
      break;  
    case 2: // read from argument string
      ts.set_input(new istringstream{argv[1]});
      break; 
    default:
      error("too many arguments");
      return 1;
    }

    table["pi"] = 3.1415926535897932385; // insert predeﬁned names
    table["e"] = 2.7182818284590452354;

    calculate();

    return no_of_errors;
  }
  ```
  - We need only a driver to start things.
  - `main()` to do setup and error reporting.
  - `calculate()` to handle the actual calculation.
  - `main()` returns zero if the program terminates normally and nonzero otherwise
  - Testing for `Kind::print` relieves `expr()` of the responsibility for handling empty expressions.
  - `main()` is given two arguments
    - The number of arguments, conventionally called `argc`.
    - An array of arguments, conventionally called `argv`.
    - The arguments are C-style character strings, so the type of `argv` is `char*[argc+1]`.
    - **The name of the program is passed as `argv[0]`, so argc is always at least 1.**
    - Run `dc "rate=1.1934;150/rate;19.75/rate;217/rate"`.
  - To read from the command string in the same way that we read from the input stream, `istringstream` is used.
  ```C++
  vector<string> arguments(int argc, char* argv[])
  {
    vector<string> res;
    for (int i = 0; i!=argc; ++i)
      res.push_back(argv[i]);
    return res;
  }
  ```
  - **`argc` and `argv` are still a source of minor, yet annoying, bugs**.

## Operator

| Operator Summary                    |                                                           |
|-------------------------------------|-----------------------------------------------------------|
| Parenthesized expression            | `(` expr `)`                                              |
| Lambda                              | `[` capture-list `]` lambda-declarator `{` stmt-List `}`  |
| Scope resolution                    | class-name `::` member                                    |
| Scope resolution                    | namespace-name `::` member                                |
| Global                              | `::` name                                                 |
| Member selection                    | object `.` member                                         |
| Member selection                    | pointer `−>` member                                       |
| Subscripting                        | pointer `[` expr `]`                                      |
| Function call                       | expr `(` expr-list `)`                                    |
| Value construction                  | type `{` expr-list `}`                                    |
| Function-style type conversion      | type `(` expr-list `)`                                    |
| Post increment                      | lvalue `++`                                               |
| Post decrement                      | lvalue `−−`                                               |
| Type identiﬁcation                  | typeid `(` type `)`                                       |
| Run-time type identiﬁcation         | typeid `(` expr `)`                                       |
| Run-time checked conversion         | `dynamic_cast<` type `>` `(` expr `)`                     |
| Compile-time checked conversion     | `static_cast<` type `>` `(` expr `)`                      |
| Unchecked conversion                | `reinterpret_cast<` type > `(` expr `)`                   |
| const conversion                    | `const_cast<` type > `(` expr `)`                         |
| Size of object                      | `sizeof` expr                                             |
| Size of type                        | `sizeof (` type `)`                                       |
| Size of parameter pack              | `sizeof...` name                                          |
| Alignment of type                   | `alignof (` type `)`                                      |
| Pre increment                       | `++` lvalue                                               |
| Pre decrement                       | `−−` lvalue                                               |
| Complement                          | `~`expr                                                   |
| Not                                 | `!` expr                                                  |
| Unary minus                         | `−` expr                                                  |
| Unary plus                          | `+` expr                                                  |
| Address of                          | `&` lvalue                                                |
| Dereference                         | `*` expr                                                  |
| Create (allocate)                   | `new` type                                                |
| Create (allocate and initialize)    | `new` type `(` expr-list `)`                              |
| Create (allocate and initialize)    | `new` type `{` expr-list `}`                              |
| Create (place)                      | `new` `(` expr-list `)` type                              |
| Create (place and initialize)       | `new` `(` expr-list `)` type `(` expr-list `)`            |
| Create (place and initialize)       | `new` `(` expr-list `)` type `{` expr-list `}`            |
| Destroy (deallocate)                | `delete` pointer                                          |
| Destroy array                       | `delete[]` pointer                                        |
| Can expression throw?               | `noexcept (` expr `)`                                     |
| Cast (type conversion)              | `(` type `)` expr                                         |
| Member selection                    | object `.*` pointer-to-member                             |
| Member selection                    | pointer `−>*` pointer-to-member                           |
| Multiply                            | expr `*` expr                                             |
| Divide                              | expr `/` expr                                             |
| Modulo (remainder)                  | expr `%` expr                                             |
| Add (plus)                          | expr `+` expr                                             |
| Subtract (minus)                    | expr `−` expr                                             |
| Shift left                          | expr `<<` expr                                            |
| Shift right                         | expr `>>` expr                                            |
| Less than                           | expr `<` expr                                             |
| Less than or equal                  | expr `<=` expr                                            |
| Greater than                        | expr `>` expr                                             |
| Greater than or equal               | expr `>=` expr                                            |
| Equal                               | expr `==` expr                                            |
| Not equal                           | expr `!=` expr                                            |
| Bitwise and                         | expr `&` expr                                             |
| Bitwise exclusive-or                | expr `ˆ` expr                                             |
| Bitwise inclusive-or                | expr `\|` expr                                            |
| Logical and                         | expr `&&` expr                                            |
| Logical inclusive or                | expr `\|\|` expr                                          |
| Conditional expression              | expr `?` expr `:` expr                                    |
| List                                | `{` expr-list `}`                                         |
| Throw exception                     | `throw` expr                                              |
| Simple assignment                   | lvalue `=` expr                                           |
| Multiply and assign                 | lvalue `*`= expr                                          |
| Divide and assign                   | lvalue `/=` expr                                          |
| Modulo and assign                   | lvalue `%=` expr                                          |
| Add and assign                      | lvalue `+=` expr                                          |
| Subtract and assign                 | lvalue `−=` expr                                          |
| Shift left and assign               | lvalue `<<=` expr                                         |
| Shift right and assign              | lvalue `>>=` expr                                         |
| Bitwise and and assign              | lvalue `&=` expr                                          |
| Bitwise inclusive-or and assign     | lvalue `\|=` expr                                         |
| Bitwise exclusive-or and assign     | lvalue `ˆ=` expr                                          |
| comma (sequencing)                  | expr `,` expr                                             |

- Each operator is followed by one or more names commonly used for it.
- You can deﬁne meanings for operators applied to operands of user-deﬁned types