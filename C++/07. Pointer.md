## Pointers
```C++
char c = 'a';
char* p = &c; // p holds the address of c; & is the address-of operator
char c2 = *p; // c2 == ’a’; * is the dereference operator
```
- For a type `T`, `T*` is the type ‘‘pointer to `T`.’’. `T*` can hold **the address of an object** of type T.
- Dereference operator (prefix *), also called *indirection*, that is, refers to the object pointed to by the pointer.
- Few machines can directly address an individual bit. Consequently, the **smallest object that can be independently allocated and pointed is `char`**.
- A bool occupies at least as much space as a char (
```C++
int* pi; // pointer to int 
char** ppc; // pointer to pointer to char
int* ap[15];  // array of 15 pointers to ints
int (*fp)(char*); // pointer to function taking a char* argument; returns an int
int* f(char*); // function taking a char* argument;
```
- **Pointers to functions** can be useful.
- We can perform some arithmetic operations on pointers to array elements.
***
- `void*`
    ```C++
    void f(int* pi)
    {
        void* pv = pi; // ok: implicit conversion of int* to void*
        *pv; // error: can’t dereference void*
        ++pv; // error: can’t increment void* (the size of the object pointed to is unknown)

        int* pi2 = static_cast<int*>(pv); // explicit conversion back to int*

        double* pd1 = pv; // error
        double* pd2 = pi; // error 
        double* pd3 = static_cast<double*>(pv); // unsafe
    s}
    ```
    - A pointer to **any type** of object can be assigned to `void*`, except a pointer to function or a pointer to member.
    - A `void*` can be **explicitly converted** to another type. However, other operations result in compile-time errors.
    - In general, it is not safe to use a pointer that has been converted (‘‘cast’’) to a type that differs from the type of the object pointed to.
    - Functions using void* pointers typically exist at the very lowest level of the system, where real hardware resources are manipulated.
***
- `nullptr`
    ```C++
    int* pi = nullptr;
    double* pd = nullptr;
    int i = nullptr; // error: i is not a pointer
    ```
    - `nullptr` represents the null pointer. It can be assigned to any pointer type.
    - Before `nullptr` was introduced, zero (`0`) was used. `int* x = 0; //`
    - The *standard conversions* allow `0` to be used as a constant of pointer or pointer-to-member type.

## Arrays
```C++
ﬂoat v[3]; // an array of three ﬂoats: v[0], v[1], v[2]
char* a[32]; // an array of 32 pointers to char: a[0] .. a[31]

void f()
{
    int aa[10];
    aa[6] = 9;
    int x = aa[99]; // undefined behavior
}
```
- For a type `T`, `T[size]` is the type ‘‘array of size elements of type `T`.’’
- You can access an array using the subscript operator, [], or through a pointer deference.
- Access out of the range of an array is undefined.
- The number of elements of the array, the array bound, must be a constant expression. If you need variable bounds, use a `vector`.
```C++
int a1[10]; // 10 ints in static storage

void f()
{
    int a2 [20]; // 20 ints on the stack
    int* p = new int[40];  // 40 ints on the free store
    // ...
}
``` 
- An array can be allocated statically, on the stack, or on the free store.
- If you allocate an array on the free store, be sure to `delete[] `its pointer once only and only after its last use
***
- Array Initializers
    ```C++
    int v1[] = { 1, 2, 3, 4 };
    char v2[] = { 'a', 'b', 'c', 0 };
    char v3[2] = { 'a', 'b', 0 }; // error : too many initializers
    char v4[3] = { 'a', 'b', 0 };  // OK

    int v5[8] = { 1, 2, 3, 4 /*, 0, 0, 0, 0*/ };
    ``` 
    - When an array is declared without a specific size, but with an initializer list, the size is decided by the initializer list.
    - If a size is explicitly specified, it is an error to give surplus elements
    - If the initializer supplies too few elements for an array, default value of the type is used for the rest.
    ```c++
    int v6[8] = v5; // error: can’t copy an array (cannot assign an int* to an array)
    v6 = v5; // error: no array assignment
    ``` 
    - **There is no built-in copy operation for arrays**, neither is array assignment.
    - When you need assignment to a collection of objects, use a `vector`, `array`, or `valarray`.
***
- String Literals
    ```C++
    sizeof("Bohr")==5
    ```
    - A string literal contains one more character than it appears to have; it is terminated by the **null character**, `'\0'`, with the value 0.
    - It is possible to have the null character in a string, but most programs will not suspect that there are characters after it.
    ```C++
    void f() {
        char p[] = "Zeno"; // p is an array of 5 char
        p[0] = 'R'; // OK
    }

    void f()
    {
        char* p = "Plato"; // error, but accepted in pre-C++11-standard code
        p[4] = 'e'; // error: assignment to const
    }
    ``` 
    - The type of a string literal is "array of the appropriate number of **`const`** characters".
    - If we want a string that we are guaranteed to be able to modify, we must place the characters in a non-`const` array
    ```C++
    const char* error_message(int i) {
        // ...
        return "range error";
    }
    ```
    - A string literal is **statically allocated** so that it is safe to return one from a function.
    ```C++
    char alpha[] = "abcdefghijklmnopqrstuvwxyz" 
                    "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

    char concat[] = "abc" "def";
    ```
    - **Long strings can be broken by whitespace** to make the program text neater. 
    ```C++
    string s = "\\w\\\\w";
    string s = R"(\w\\w)";

    R"("quoted string")"; // the string is "quoted string"
    R"***("quoted string containing the usual terminator ("))")***" // "quoted string containing the usual terminator ("))"
    ```
    - To represent a backslash (`\`) or a double quote (`) in a string literal, we have to precede it with a backslash.
    - A backslash is an escape character becomes a notable source of errors.
    - C++ provides *raw string literals* which is a string literal where a backslash is just a backslash and a double quote is just a double quote.
    - Raw string literals use the `R"(ccc)"` notation for a sequence of characters `ccc`.
    - `"(` and `)"` is only the default delimiter pair.
    - The character sequence after the` )` identical to the sequence before the `(` can be treated as delimiters.
    ```C++
    string counts {R"(1
    22
    333)"};
    string x {"1\n22\n333"};
    ``` 
    - In contrast to nonraw string literals, **a raw string literal can contain a newline**.
    ```C++
    "folder\\file"; // implementation character set string
    R"(folder\file)"; // implementation character raw set string
    u8"folder\\file"; // UTF-8 string
    u8R"(folder\file)";  // UTF-8 raw string
    u"folder\\file";  // UTF-16 string
    uR"(folder\file)"; // UTF-16 raw string
    U"folder\\file"; // UTF-32 string
    UR"(folder\file)"; // UTF-32 raw string
    L"(folder\file)"; // wchar_t string

    u8"The ofﬁcial vowels in Danish are: a, e, i, o, u, \u00E6, \u00F8, \u00E5 and y." // The ofﬁcial vowels in Danish are: a, e, i, o, u, æ, ø, å and y.
    ``` 
    - A string with the prefix `L`, such as `L"angst"`, is a string of wide characters.
    - There are three major encodings of Unicode: UTF-8, UTF-16, and UTF-32.
    - UTF-8 is a **variable-width encoding**
      - common characters ﬁt into 1 byte
      - less frequently used characters into 2 bytes
      - rarer characters into 3 or 4 bytes.
    - The hexadecimal number after the `\u` is a **Unicode code point**

## Pointers into Arrays
```C++
int v[] = { 1, 2, 3, 4 };
int∗ p1 = v; // pointer to initial element (implicit conversion)
int∗ p2 = &v[0];  // pointer to initial element 
int∗ p3 = v+4; // pointer to one-beyond-last element

int∗ p4 = v−1; // before the beginning, undeﬁned: don’t do it
int∗ p5 = v+7; // beyond the end, undeﬁned: don’t do it
```
![Pointer to array](images/ArrayPointer.png)
- The name of an array can be used as a pointer to its **initial element**.
- Taking a pointer to the element **one beyond the end** of an array is guaranteed to work.
- Taking the address of the element before the initial element or beyond one-past-the-last element is undeﬁned.
```C++
extern "C" int strlen(const char∗); // from <string.h>

void f()
{
    char v[] = "Annemarie";
    char∗ p = v; // implicit conversion of char[] to char*

    strlen(p); 
    strlen(v); // implicit conversion of char[] to char* 

    v = p; // error: cannot assign to array
}
``` 
- The size of the array is lost when it is converted to pointer.
- **There is no implicit or explicit conversion from a pointer to an array**.
- `strlen()` relies on zero to indicate end-of-string;
```C++
void ﬁ(char v[])
{
    for (int i = 0; v[i]!=0; ++i)
        use(v[i]);
}

void fp(char v[])
{
    for (char∗ p = v; ∗p!=0; ++p)
        use(∗p);
}
```
- Access can be achieved either through **a pointer plus an index** or through a pointer to an element.
- There is no inherent reason why one version should be faster than the other.
- `∗p!=0;` is used to stop loop for a pointer to `char[]`.
- `a[j] == ∗(&a[0]+j) == ∗(a+j) == ∗(j+a) == j[a]`.
- It usually surprises people to ﬁnd that **`a[j]==j[a]`**. For example, `3["Texas"]=="Texas"[3]=='a'`.

## References