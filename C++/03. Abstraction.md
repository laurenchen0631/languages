## Concrete Class
- Concrete classes is that they behave **just like built-in types.**
- Concrete type is that **its representation is part of its deﬁnition**.
  - In many important cases, such as a `vector`, that representation is only one or more pointers to more data stored elsewhere.
  - Place objects of concrete types on the **stack, in statically allocated memory.**
  - Refer to objects directly (and not just through pointers or references).
  - Initialize objects immediately and completely.
  - Copy objects
- If the representation changes in any signiﬁcant way, a user must **recompile**.
- To increase ﬂexibility, a concrete type can keep major parts of its representation on the free store (dynamic memory, heap) and access them through the part stored in the class object itself.

```C++
class complex {
    double re, im; // representation: two doubles
    
    public:
    complex(double r, double i) :re{r}, im{i} {}
    complex(double r) :re{r}, im{0} {}
    complex() :re{0}, im{0} {} // default constructor

    double real() const { return re; }
    void real(double d) { re=d; }
    double imag() const { return im; }
    void imag(double d) { im=d; }

    complex& operator+=(complex z) { re+=z.re, im+=z.im; return ∗this; }
    complex& operator−=(complex z) { re−=z.re, im−=z.im; return ∗this; }
    complex& operator∗=(complex); // deﬁned out-of-class somewhere
    complex& operator/=(complex); // deﬁned out-of-class somewhere
}
```
- The class deﬁnition itself contains only the operations requiring access to the representation.
- Functions deﬁned in a class are **inlined by default.** (Function calls will not be generated machine code)
- A constructor **without an argument** is called a default constructor.
- By deﬁning a default constructor you eliminate the possibility of uninitialized variables of that type.
```C++
complex operator+(complex a, complex b) { return a+=b; }
complex operator−(complex a, complex b) { return a−=b; }
complex operator−(complex a) { return {−a.real(), −a.imag()}; }
complex operator∗(complex a, complex b) { return a∗=b; }
complex operator/(complex a, complex b) { return a/=b; }

bool operator==(complex a, complex b)
{
    return a.real()==b.real() && a.imag()==b.imag();
}

bool operator!=(complex a, complex b)
{
    return !(a==b);
}

complex sqrt(complex);

void f(complex z) {
    complex a {2.3};
    complex b {1/a};
    complex c {a+z∗complex{1,2.3}};
    if (c != b)
        c = −(b/a)+2∗b;
}
```
- These operations do not require direct access to the representation of complex, so they can be deﬁned separately from the class deﬁnition.
- **An argument passed by value is copied**, so that modifying an argument won't affect the caller’s copy.
```C++
class Vector {
private:
    double∗ elem;
    int sz;
public:
    Vector(int s) :elem{new double[s]}, sz{s}
    {
        for (int i=0; i!=s; ++i) elem[i]=0;
    }

    ~Vector() { delete[] elem; }

    double& operator[](int i) { return elem[i]; }
    int size() { return sz; }
};
```
- A *container* is an object holding a collection of elements.
- `~class`: destructor of the class
- The constructor/destructor combination is the basis for most C++ general resource management techniques.
- You use constructor and destructor to **eliminate naked `new` and `delete`** operations.
```C++
class Vector {
public:
    Vector::Vector(std::initializer_list<double> lst) :elem{new double[lst.size()]}, sz{lst.size()}
    {
        copy(lst.begin(),lst.end(),elem);
    }
    // ...
    void push_back(double);
    // ...
};

Vector read(istream& is) {
    Vector v;
    for (double d; is>>d;) // read ﬂoating-point values into d
        v.push_back(d);
    return v;
}
```
- A container exists to hold elements, so obviously we need convenient ways of getting elements into a container.
- `initializer-list` constructor: Initialize with a list of elements.
- `push_back()`: Add a new element at the end (at the back of) the sequence.
- When we use a `{}`-list, such as` {1,2,3,4}`, the **compiler will create an object of type `initializer_list`** to give to the program.

## Abstract Class
- An abstract type is a type that completely **insulates a user from implementation details**.
- We decouple the interface from the representation and give up genuine local variables.
- We must allocate objects on the free store and **access them through references or pointers**.
```C++
class Container {
public:
    virtual double& operator[](int) = 0;
    virtual int size() const = 0;
    virtual ~Container() {}
};
```
- This class is a pure interface to speciﬁc containers deﬁned later.
- `Container` can only serve as the interface to a class that implements its `operator[]()` and `size()` functions.
- `virtual` means may be redeﬁned later in a class derived from this one.
- A function declared virtual is called a *virtual function*.
- `=0` syntax says the function is *pure virtual*; that is, some class derived from Container must deﬁne the function.
- A class with a **pure virtual function** is called an *abstract class*.
- As is common for abstract classes, `Container` does **not have a constructor**. On the other hand, `Container` does have a destructor and that destructor is `virtual`.
```C++
void use(Container& c)
{
    const int sz = c.size();
    for (int i=0; i!=sz; ++i)
        cout << c[i] << '\n';
}
```
- `use()` uses the `Container` interface in complete ignorance of implementation details
- A class that **provides the interface to a variety of other classes** is often called a *polymorphic type*.
- `use(Container&)` needn’t be recompiled if the derived implementation changes or a brand-new class derived from Container is used.
- The **flip side** of this ﬂexibility is that objects must be manipulated through **pointers or references**.
```C++
class Vector_container : public Container {
    Vector v;
public:
    Vector_container(int s) : v(s) { } 
    double& operator[](int i) { return v[i]; }
    int size() const { return v.size(); }
};

class List_container : public Container { 
    implements Container std::list<double> ld;

    List_container() { } // empty List
    List_container(initializer_list<double> il) : ld{il} { } ~List_container() {}

    double& operator[](int i);
    int size() const { return ld.size();
};

double& List_container::operator[](int i) {
    for (auto& x : ld) {
        if (i==0) return x;
        −−i;
    }
    throw out_of_range("List container");
}
```
- The `:public` can be read as "is derived from" or "is a subtype of."
- An alternative terminology calls `Vector_container` and `Container` *subclass* and *superclass*,
- Derived classes is commonly referred to as *inheritance*.
- `operator[]()`, `size()`, and destructor *override* the corresponding members in the base class Container
![Virtual Function Table](images/VirtualFunctionTable.png)
- A `Container` object must contain information to allow it to select the right function to call at run time.
- The compiler will convert the name of a virtual function into an index into a table, *virtual function table* or `vtbl`, of pointers to functions.
- A virtual class's space overhead is **one pointer to `vtbl` in each object** plus **one `vtbl` for each such class.** Same class shares the same `vtbl`.